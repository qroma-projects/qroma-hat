// @generated by protobuf-ts 2.9.3 with parameter use_proto_field_name,generate_dependencies
// @generated from protobuf file "my-project-messages.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// enum UpdateType {//   UpdateType_NotSet = 0;//   UpdateType_None = 1;//   UpdateType_Interval = 2;// }

// message UpdateConfiguration {//   UpdateType updateType = 1;//   uint32 updateIntervalInMs = 2;// }

// message SetUpdateConfiguration {//   UpdateConfiguration updateConfiguration = 1;//   bool saveConfiguration = 2;// }

/**
 * @generated from protobuf message SetHatRotateImageCommand
 */
export interface SetHatRotateImageCommand {
    /**
     * @generated from protobuf field: bool rotateImage = 1;
     */
    rotateImage: boolean;
}
/**
 * @generated from protobuf message SetHatImageCommand
 */
export interface SetHatImageCommand {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
}
/**
 * @generated from protobuf message SetPlaybackDirectoryCommand
 */
export interface SetPlaybackDirectoryCommand {
    /**
     * @generated from protobuf field: string playbackDir = 1;
     */
    playbackDir: string;
}
/**
 * @generated from protobuf message GetDgsrImageValidationResultCommand
 */
export interface GetDgsrImageValidationResultCommand {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
}
/**
 * @generated from protobuf message PlaybackSettings_ShowSingleFile
 */
export interface PlaybackSettings_ShowSingleFile {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
}
/**
 * @generated from protobuf message PlaybackSettings_UseDirectoryForRandomFileSlideshow
 */
export interface PlaybackSettings_UseDirectoryForRandomFileSlideshow {
    /**
     * @generated from protobuf field: string slideshowDirPath = 1;
     */
    slideshowDirPath: string;
    /**
     * @generated from protobuf field: uint32 delayIntervalInMs = 2;
     */
    delayIntervalInMs: number;
}
/**
 * @generated from protobuf message SetPlaybackCommand
 */
export interface SetPlaybackCommand {
    /**
     * @generated from protobuf oneof: playback
     */
    playback: {
        oneofKind: "showSingleFile";
        /**
         * @generated from protobuf field: PlaybackSettings_ShowSingleFile showSingleFile = 2;
         */
        showSingleFile: PlaybackSettings_ShowSingleFile;
    } | {
        oneofKind: "dirSlideshow";
        /**
         * @generated from protobuf field: PlaybackSettings_UseDirectoryForRandomFileSlideshow dirSlideshow = 3;
         */
        dirSlideshow: PlaybackSettings_UseDirectoryForRandomFileSlideshow;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message PlaybackConfiguration
 */
export interface PlaybackConfiguration {
    /**
     * @generated from protobuf field: PlaybackMode mode = 1;
     */
    mode: PlaybackMode;
    /**
     * @generated from protobuf field: PlaybackSettings_ShowSingleFile showSingleFileSettings = 2;
     */
    showSingleFileSettings?: PlaybackSettings_ShowSingleFile;
    /**
     * @generated from protobuf field: PlaybackSettings_UseDirectoryForRandomFileSlideshow dirSlideshowSettings = 3;
     */
    dirSlideshowSettings?: PlaybackSettings_UseDirectoryForRandomFileSlideshow;
    /**
     * @generated from protobuf field: bool isSlideshowPaused = 4;
     */
    isSlideshowPaused: boolean;
    /**
     * @generated from protobuf field: uint32 randomSeed = 10;
     */
    randomSeed: number;
}
/**
 * @generated from protobuf message HatConfiguration
 */
export interface HatConfiguration {
    /**
     * @generated from protobuf field: string activeImagePath = 1;
     */
    activeImagePath: string;
    /**
     * @generated from protobuf field: bool rotateImage = 2;
     */
    rotateImage: boolean;
    /**
     * @generated from protobuf field: PlaybackConfiguration playbackSettings = 3;
     */
    playbackSettings?: PlaybackConfiguration;
}
/**
 * @generated from protobuf message MyProjectCommand
 */
export interface MyProjectCommand {
    /**
     * @generated from protobuf oneof: command
     */
    command: {
        oneofKind: "noArgCommand";
        /**
         * @generated from protobuf field: NoArgCommands noArgCommand = 1;
         */
        noArgCommand: NoArgCommands;
    } | {
        oneofKind: "setHatImage";
        /**
         * @generated from protobuf field: SetHatImageCommand setHatImage = 2;
         */
        setHatImage: SetHatImageCommand;
    } | {
        oneofKind: "setHatRotateImage";
        /**
         * @generated from protobuf field: SetHatRotateImageCommand setHatRotateImage = 3;
         */
        setHatRotateImage: SetHatRotateImageCommand;
    } | {
        oneofKind: "getDgsrImageValidationResult";
        /**
         * @generated from protobuf field: GetDgsrImageValidationResultCommand getDgsrImageValidationResult = 4;
         */
        getDgsrImageValidationResult: GetDgsrImageValidationResultCommand;
    } | {
        oneofKind: "setPlayback";
        /**
         * @generated from protobuf field: SetPlaybackCommand setPlayback = 5;
         */
        setPlayback: SetPlaybackCommand;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message InvalidCommandResponse
 */
export interface InvalidCommandResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message ConfigurationResponse
 */
export interface ConfigurationResponse {
    /**
     * UpdateConfiguration updateConfiguration = 1;
     *
     * @generated from protobuf field: HatConfiguration hatConfiguration = 2;
     */
    hatConfiguration?: HatConfiguration;
}
/**
 * @generated from protobuf message FirmwareDetailsResponse
 */
export interface FirmwareDetailsResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: string buildTime = 2;
     */
    buildTime: string;
}
/**
 * @generated from protobuf message UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: uint32 boardUptimeInMs = 1;
     */
    boardUptimeInMs: number;
}
/**
 * @generated from protobuf message SetHatImageResponse
 */
export interface SetHatImageResponse {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message GetDgsrImageValidationResultResponse
 */
export interface GetDgsrImageValidationResultResponse {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
    /**
     * @generated from protobuf field: bool isValid = 2;
     */
    isValid: boolean;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message MyProjectResponse
 */
export interface MyProjectResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "invalidCommandResponse";
        /**
         * @generated from protobuf field: InvalidCommandResponse invalidCommandResponse = 1;
         */
        invalidCommandResponse: InvalidCommandResponse;
    } | {
        oneofKind: "firmwareDetailsResponse";
        /**
         * @generated from protobuf field: FirmwareDetailsResponse firmwareDetailsResponse = 2;
         */
        firmwareDetailsResponse: FirmwareDetailsResponse;
    } | {
        oneofKind: "updateResponse";
        /**
         * @generated from protobuf field: UpdateResponse updateResponse = 3;
         */
        updateResponse: UpdateResponse;
    } | {
        oneofKind: "configurationResponse";
        /**
         * @generated from protobuf field: ConfigurationResponse configurationResponse = 4;
         */
        configurationResponse: ConfigurationResponse;
    } | {
        oneofKind: "setHatImageResponse";
        /**
         * @generated from protobuf field: SetHatImageResponse setHatImageResponse = 5;
         */
        setHatImageResponse: SetHatImageResponse;
    } | {
        oneofKind: "getDgsrImageValidationResultResponse";
        /**
         * @generated from protobuf field: GetDgsrImageValidationResultResponse getDgsrImageValidationResultResponse = 6;
         */
        getDgsrImageValidationResultResponse: GetDgsrImageValidationResultResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum NoArgCommands
 */
export enum NoArgCommands {
    /**
     * @generated from protobuf enum value: Nac_NotSet = 0;
     */
    Nac_NotSet = 0,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToWhite = 1;
     */
    Nac_ClearScreenToWhite = 1,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToBlack = 2;
     */
    Nac_ClearScreenToBlack = 2,
    /**
     * @generated from protobuf enum value: Nac_ShowDefaultImage = 3;
     */
    Nac_ShowDefaultImage = 3,
    /**
     * @generated from protobuf enum value: Nac_GetConfiguration = 4;
     */
    Nac_GetConfiguration = 4,
    /**
     * @generated from protobuf enum value: Nac_AdvancePlayback = 5;
     */
    Nac_AdvancePlayback = 5,
    /**
     * @generated from protobuf enum value: Nac_UserPausePlayback = 6;
     */
    Nac_UserPausePlayback = 6,
    /**
     * @generated from protobuf enum value: Nac_UserUnpausePlayback = 7;
     */
    Nac_UserUnpausePlayback = 7
}
/**
 * @generated from protobuf enum PlaybackMode
 */
export enum PlaybackMode {
    /**
     * @generated from protobuf enum value: Pbm_NotSet = 0;
     */
    Pbm_NotSet = 0,
    /**
     * @generated from protobuf enum value: Pbm_ShowDefaultImage = 1;
     */
    Pbm_ShowDefaultImage = 1,
    /**
     * @generated from protobuf enum value: Pbm_ShowSingleFile = 2;
     */
    Pbm_ShowSingleFile = 2,
    /**
     * @generated from protobuf enum value: Pbm_UseDirectoryForRandomFileSlideshow = 3;
     */
    Pbm_UseDirectoryForRandomFileSlideshow = 3,
    /**
     * @generated from protobuf enum value: Pbm_ShowWhiteScreen = 4;
     */
    Pbm_ShowWhiteScreen = 4,
    /**
     * @generated from protobuf enum value: Pbm_ShowBlackScreen = 5;
     */
    Pbm_ShowBlackScreen = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class SetHatRotateImageCommand$Type extends MessageType<SetHatRotateImageCommand> {
    constructor() {
        super("SetHatRotateImageCommand", [
            { no: 1, name: "rotateImage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatRotateImageCommand>): SetHatRotateImageCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rotateImage = false;
        if (value !== undefined)
            reflectionMergePartial<SetHatRotateImageCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatRotateImageCommand): SetHatRotateImageCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rotateImage */ 1:
                    message.rotateImage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatRotateImageCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rotateImage = 1; */
        if (message.rotateImage !== false)
            writer.tag(1, WireType.Varint).bool(message.rotateImage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatRotateImageCommand
 */
export const SetHatRotateImageCommand = new SetHatRotateImageCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHatImageCommand$Type extends MessageType<SetHatImageCommand> {
    constructor() {
        super("SetHatImageCommand", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatImageCommand>): SetHatImageCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        if (value !== undefined)
            reflectionMergePartial<SetHatImageCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatImageCommand): SetHatImageCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatImageCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatImageCommand
 */
export const SetHatImageCommand = new SetHatImageCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlaybackDirectoryCommand$Type extends MessageType<SetPlaybackDirectoryCommand> {
    constructor() {
        super("SetPlaybackDirectoryCommand", [
            { no: 1, name: "playbackDir", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetPlaybackDirectoryCommand>): SetPlaybackDirectoryCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playbackDir = "";
        if (value !== undefined)
            reflectionMergePartial<SetPlaybackDirectoryCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlaybackDirectoryCommand): SetPlaybackDirectoryCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string playbackDir */ 1:
                    message.playbackDir = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlaybackDirectoryCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string playbackDir = 1; */
        if (message.playbackDir !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.playbackDir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlaybackDirectoryCommand
 */
export const SetPlaybackDirectoryCommand = new SetPlaybackDirectoryCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDgsrImageValidationResultCommand$Type extends MessageType<GetDgsrImageValidationResultCommand> {
    constructor() {
        super("GetDgsrImageValidationResultCommand", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDgsrImageValidationResultCommand>): GetDgsrImageValidationResultCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        if (value !== undefined)
            reflectionMergePartial<GetDgsrImageValidationResultCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDgsrImageValidationResultCommand): GetDgsrImageValidationResultCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDgsrImageValidationResultCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDgsrImageValidationResultCommand
 */
export const GetDgsrImageValidationResultCommand = new GetDgsrImageValidationResultCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaybackSettings_ShowSingleFile$Type extends MessageType<PlaybackSettings_ShowSingleFile> {
    constructor() {
        super("PlaybackSettings_ShowSingleFile", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PlaybackSettings_ShowSingleFile>): PlaybackSettings_ShowSingleFile {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        if (value !== undefined)
            reflectionMergePartial<PlaybackSettings_ShowSingleFile>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaybackSettings_ShowSingleFile): PlaybackSettings_ShowSingleFile {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaybackSettings_ShowSingleFile, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlaybackSettings_ShowSingleFile
 */
export const PlaybackSettings_ShowSingleFile = new PlaybackSettings_ShowSingleFile$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaybackSettings_UseDirectoryForRandomFileSlideshow$Type extends MessageType<PlaybackSettings_UseDirectoryForRandomFileSlideshow> {
    constructor() {
        super("PlaybackSettings_UseDirectoryForRandomFileSlideshow", [
            { no: 1, name: "slideshowDirPath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "delayIntervalInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlaybackSettings_UseDirectoryForRandomFileSlideshow>): PlaybackSettings_UseDirectoryForRandomFileSlideshow {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.slideshowDirPath = "";
        message.delayIntervalInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<PlaybackSettings_UseDirectoryForRandomFileSlideshow>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaybackSettings_UseDirectoryForRandomFileSlideshow): PlaybackSettings_UseDirectoryForRandomFileSlideshow {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string slideshowDirPath */ 1:
                    message.slideshowDirPath = reader.string();
                    break;
                case /* uint32 delayIntervalInMs */ 2:
                    message.delayIntervalInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaybackSettings_UseDirectoryForRandomFileSlideshow, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string slideshowDirPath = 1; */
        if (message.slideshowDirPath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.slideshowDirPath);
        /* uint32 delayIntervalInMs = 2; */
        if (message.delayIntervalInMs !== 0)
            writer.tag(2, WireType.Varint).uint32(message.delayIntervalInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlaybackSettings_UseDirectoryForRandomFileSlideshow
 */
export const PlaybackSettings_UseDirectoryForRandomFileSlideshow = new PlaybackSettings_UseDirectoryForRandomFileSlideshow$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetPlaybackCommand$Type extends MessageType<SetPlaybackCommand> {
    constructor() {
        super("SetPlaybackCommand", [
            { no: 2, name: "showSingleFile", kind: "message", oneof: "playback", T: () => PlaybackSettings_ShowSingleFile },
            { no: 3, name: "dirSlideshow", kind: "message", oneof: "playback", T: () => PlaybackSettings_UseDirectoryForRandomFileSlideshow }
        ]);
    }
    create(value?: PartialMessage<SetPlaybackCommand>): SetPlaybackCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.playback = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SetPlaybackCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetPlaybackCommand): SetPlaybackCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* PlaybackSettings_ShowSingleFile showSingleFile */ 2:
                    message.playback = {
                        oneofKind: "showSingleFile",
                        showSingleFile: PlaybackSettings_ShowSingleFile.internalBinaryRead(reader, reader.uint32(), options, (message.playback as any).showSingleFile)
                    };
                    break;
                case /* PlaybackSettings_UseDirectoryForRandomFileSlideshow dirSlideshow */ 3:
                    message.playback = {
                        oneofKind: "dirSlideshow",
                        dirSlideshow: PlaybackSettings_UseDirectoryForRandomFileSlideshow.internalBinaryRead(reader, reader.uint32(), options, (message.playback as any).dirSlideshow)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetPlaybackCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* PlaybackSettings_ShowSingleFile showSingleFile = 2; */
        if (message.playback.oneofKind === "showSingleFile")
            PlaybackSettings_ShowSingleFile.internalBinaryWrite(message.playback.showSingleFile, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* PlaybackSettings_UseDirectoryForRandomFileSlideshow dirSlideshow = 3; */
        if (message.playback.oneofKind === "dirSlideshow")
            PlaybackSettings_UseDirectoryForRandomFileSlideshow.internalBinaryWrite(message.playback.dirSlideshow, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetPlaybackCommand
 */
export const SetPlaybackCommand = new SetPlaybackCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlaybackConfiguration$Type extends MessageType<PlaybackConfiguration> {
    constructor() {
        super("PlaybackConfiguration", [
            { no: 1, name: "mode", kind: "enum", T: () => ["PlaybackMode", PlaybackMode] },
            { no: 2, name: "showSingleFileSettings", kind: "message", T: () => PlaybackSettings_ShowSingleFile },
            { no: 3, name: "dirSlideshowSettings", kind: "message", T: () => PlaybackSettings_UseDirectoryForRandomFileSlideshow },
            { no: 4, name: "isSlideshowPaused", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "randomSeed", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlaybackConfiguration>): PlaybackConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.mode = 0;
        message.isSlideshowPaused = false;
        message.randomSeed = 0;
        if (value !== undefined)
            reflectionMergePartial<PlaybackConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlaybackConfiguration): PlaybackConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* PlaybackMode mode */ 1:
                    message.mode = reader.int32();
                    break;
                case /* PlaybackSettings_ShowSingleFile showSingleFileSettings */ 2:
                    message.showSingleFileSettings = PlaybackSettings_ShowSingleFile.internalBinaryRead(reader, reader.uint32(), options, message.showSingleFileSettings);
                    break;
                case /* PlaybackSettings_UseDirectoryForRandomFileSlideshow dirSlideshowSettings */ 3:
                    message.dirSlideshowSettings = PlaybackSettings_UseDirectoryForRandomFileSlideshow.internalBinaryRead(reader, reader.uint32(), options, message.dirSlideshowSettings);
                    break;
                case /* bool isSlideshowPaused */ 4:
                    message.isSlideshowPaused = reader.bool();
                    break;
                case /* uint32 randomSeed */ 10:
                    message.randomSeed = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlaybackConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* PlaybackMode mode = 1; */
        if (message.mode !== 0)
            writer.tag(1, WireType.Varint).int32(message.mode);
        /* PlaybackSettings_ShowSingleFile showSingleFileSettings = 2; */
        if (message.showSingleFileSettings)
            PlaybackSettings_ShowSingleFile.internalBinaryWrite(message.showSingleFileSettings, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* PlaybackSettings_UseDirectoryForRandomFileSlideshow dirSlideshowSettings = 3; */
        if (message.dirSlideshowSettings)
            PlaybackSettings_UseDirectoryForRandomFileSlideshow.internalBinaryWrite(message.dirSlideshowSettings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool isSlideshowPaused = 4; */
        if (message.isSlideshowPaused !== false)
            writer.tag(4, WireType.Varint).bool(message.isSlideshowPaused);
        /* uint32 randomSeed = 10; */
        if (message.randomSeed !== 0)
            writer.tag(10, WireType.Varint).uint32(message.randomSeed);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlaybackConfiguration
 */
export const PlaybackConfiguration = new PlaybackConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HatConfiguration$Type extends MessageType<HatConfiguration> {
    constructor() {
        super("HatConfiguration", [
            { no: 1, name: "activeImagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rotateImage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "playbackSettings", kind: "message", T: () => PlaybackConfiguration }
        ]);
    }
    create(value?: PartialMessage<HatConfiguration>): HatConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activeImagePath = "";
        message.rotateImage = false;
        if (value !== undefined)
            reflectionMergePartial<HatConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HatConfiguration): HatConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string activeImagePath */ 1:
                    message.activeImagePath = reader.string();
                    break;
                case /* bool rotateImage */ 2:
                    message.rotateImage = reader.bool();
                    break;
                case /* PlaybackConfiguration playbackSettings */ 3:
                    message.playbackSettings = PlaybackConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.playbackSettings);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HatConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string activeImagePath = 1; */
        if (message.activeImagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.activeImagePath);
        /* bool rotateImage = 2; */
        if (message.rotateImage !== false)
            writer.tag(2, WireType.Varint).bool(message.rotateImage);
        /* PlaybackConfiguration playbackSettings = 3; */
        if (message.playbackSettings)
            PlaybackConfiguration.internalBinaryWrite(message.playbackSettings, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HatConfiguration
 */
export const HatConfiguration = new HatConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectCommand$Type extends MessageType<MyProjectCommand> {
    constructor() {
        super("MyProjectCommand", [
            { no: 1, name: "noArgCommand", kind: "enum", oneof: "command", T: () => ["NoArgCommands", NoArgCommands] },
            { no: 2, name: "setHatImage", kind: "message", oneof: "command", T: () => SetHatImageCommand },
            { no: 3, name: "setHatRotateImage", kind: "message", oneof: "command", T: () => SetHatRotateImageCommand },
            { no: 4, name: "getDgsrImageValidationResult", kind: "message", oneof: "command", T: () => GetDgsrImageValidationResultCommand },
            { no: 5, name: "setPlayback", kind: "message", oneof: "command", T: () => SetPlaybackCommand }
        ]);
    }
    create(value?: PartialMessage<MyProjectCommand>): MyProjectCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectCommand): MyProjectCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoArgCommands noArgCommand */ 1:
                    message.command = {
                        oneofKind: "noArgCommand",
                        noArgCommand: reader.int32()
                    };
                    break;
                case /* SetHatImageCommand setHatImage */ 2:
                    message.command = {
                        oneofKind: "setHatImage",
                        setHatImage: SetHatImageCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setHatImage)
                    };
                    break;
                case /* SetHatRotateImageCommand setHatRotateImage */ 3:
                    message.command = {
                        oneofKind: "setHatRotateImage",
                        setHatRotateImage: SetHatRotateImageCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setHatRotateImage)
                    };
                    break;
                case /* GetDgsrImageValidationResultCommand getDgsrImageValidationResult */ 4:
                    message.command = {
                        oneofKind: "getDgsrImageValidationResult",
                        getDgsrImageValidationResult: GetDgsrImageValidationResultCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).getDgsrImageValidationResult)
                    };
                    break;
                case /* SetPlaybackCommand setPlayback */ 5:
                    message.command = {
                        oneofKind: "setPlayback",
                        setPlayback: SetPlaybackCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setPlayback)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoArgCommands noArgCommand = 1; */
        if (message.command.oneofKind === "noArgCommand")
            writer.tag(1, WireType.Varint).int32(message.command.noArgCommand);
        /* SetHatImageCommand setHatImage = 2; */
        if (message.command.oneofKind === "setHatImage")
            SetHatImageCommand.internalBinaryWrite(message.command.setHatImage, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* SetHatRotateImageCommand setHatRotateImage = 3; */
        if (message.command.oneofKind === "setHatRotateImage")
            SetHatRotateImageCommand.internalBinaryWrite(message.command.setHatRotateImage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* GetDgsrImageValidationResultCommand getDgsrImageValidationResult = 4; */
        if (message.command.oneofKind === "getDgsrImageValidationResult")
            GetDgsrImageValidationResultCommand.internalBinaryWrite(message.command.getDgsrImageValidationResult, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* SetPlaybackCommand setPlayback = 5; */
        if (message.command.oneofKind === "setPlayback")
            SetPlaybackCommand.internalBinaryWrite(message.command.setPlayback, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectCommand
 */
export const MyProjectCommand = new MyProjectCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvalidCommandResponse$Type extends MessageType<InvalidCommandResponse> {
    constructor() {
        super("InvalidCommandResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InvalidCommandResponse>): InvalidCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InvalidCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvalidCommandResponse): InvalidCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvalidCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InvalidCommandResponse
 */
export const InvalidCommandResponse = new InvalidCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigurationResponse$Type extends MessageType<ConfigurationResponse> {
    constructor() {
        super("ConfigurationResponse", [
            { no: 2, name: "hatConfiguration", kind: "message", T: () => HatConfiguration }
        ]);
    }
    create(value?: PartialMessage<ConfigurationResponse>): ConfigurationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConfigurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigurationResponse): ConfigurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* HatConfiguration hatConfiguration */ 2:
                    message.hatConfiguration = HatConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.hatConfiguration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* HatConfiguration hatConfiguration = 2; */
        if (message.hatConfiguration)
            HatConfiguration.internalBinaryWrite(message.hatConfiguration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConfigurationResponse
 */
export const ConfigurationResponse = new ConfigurationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirmwareDetailsResponse$Type extends MessageType<FirmwareDetailsResponse> {
    constructor() {
        super("FirmwareDetailsResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buildTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FirmwareDetailsResponse>): FirmwareDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.buildTime = "";
        if (value !== undefined)
            reflectionMergePartial<FirmwareDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FirmwareDetailsResponse): FirmwareDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string buildTime */ 2:
                    message.buildTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FirmwareDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string buildTime = 2; */
        if (message.buildTime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.buildTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FirmwareDetailsResponse
 */
export const FirmwareDetailsResponse = new FirmwareDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("UpdateResponse", [
            { no: 1, name: "boardUptimeInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boardUptimeInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 boardUptimeInMs */ 1:
                    message.boardUptimeInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 boardUptimeInMs = 1; */
        if (message.boardUptimeInMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.boardUptimeInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHatImageResponse$Type extends MessageType<SetHatImageResponse> {
    constructor() {
        super("SetHatImageResponse", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatImageResponse>): SetHatImageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SetHatImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatImageResponse): SetHatImageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatImageResponse
 */
export const SetHatImageResponse = new SetHatImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDgsrImageValidationResultResponse$Type extends MessageType<GetDgsrImageValidationResultResponse> {
    constructor() {
        super("GetDgsrImageValidationResultResponse", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDgsrImageValidationResultResponse>): GetDgsrImageValidationResultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        message.isValid = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<GetDgsrImageValidationResultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDgsrImageValidationResultResponse): GetDgsrImageValidationResultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                case /* bool isValid */ 2:
                    message.isValid = reader.bool();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDgsrImageValidationResultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        /* bool isValid = 2; */
        if (message.isValid !== false)
            writer.tag(2, WireType.Varint).bool(message.isValid);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDgsrImageValidationResultResponse
 */
export const GetDgsrImageValidationResultResponse = new GetDgsrImageValidationResultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectResponse$Type extends MessageType<MyProjectResponse> {
    constructor() {
        super("MyProjectResponse", [
            { no: 1, name: "invalidCommandResponse", kind: "message", oneof: "response", T: () => InvalidCommandResponse },
            { no: 2, name: "firmwareDetailsResponse", kind: "message", oneof: "response", T: () => FirmwareDetailsResponse },
            { no: 3, name: "updateResponse", kind: "message", oneof: "response", T: () => UpdateResponse },
            { no: 4, name: "configurationResponse", kind: "message", oneof: "response", T: () => ConfigurationResponse },
            { no: 5, name: "setHatImageResponse", kind: "message", oneof: "response", T: () => SetHatImageResponse },
            { no: 6, name: "getDgsrImageValidationResultResponse", kind: "message", oneof: "response", T: () => GetDgsrImageValidationResultResponse }
        ]);
    }
    create(value?: PartialMessage<MyProjectResponse>): MyProjectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectResponse): MyProjectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* InvalidCommandResponse invalidCommandResponse */ 1:
                    message.response = {
                        oneofKind: "invalidCommandResponse",
                        invalidCommandResponse: InvalidCommandResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).invalidCommandResponse)
                    };
                    break;
                case /* FirmwareDetailsResponse firmwareDetailsResponse */ 2:
                    message.response = {
                        oneofKind: "firmwareDetailsResponse",
                        firmwareDetailsResponse: FirmwareDetailsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).firmwareDetailsResponse)
                    };
                    break;
                case /* UpdateResponse updateResponse */ 3:
                    message.response = {
                        oneofKind: "updateResponse",
                        updateResponse: UpdateResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).updateResponse)
                    };
                    break;
                case /* ConfigurationResponse configurationResponse */ 4:
                    message.response = {
                        oneofKind: "configurationResponse",
                        configurationResponse: ConfigurationResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).configurationResponse)
                    };
                    break;
                case /* SetHatImageResponse setHatImageResponse */ 5:
                    message.response = {
                        oneofKind: "setHatImageResponse",
                        setHatImageResponse: SetHatImageResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).setHatImageResponse)
                    };
                    break;
                case /* GetDgsrImageValidationResultResponse getDgsrImageValidationResultResponse */ 6:
                    message.response = {
                        oneofKind: "getDgsrImageValidationResultResponse",
                        getDgsrImageValidationResultResponse: GetDgsrImageValidationResultResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).getDgsrImageValidationResultResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* InvalidCommandResponse invalidCommandResponse = 1; */
        if (message.response.oneofKind === "invalidCommandResponse")
            InvalidCommandResponse.internalBinaryWrite(message.response.invalidCommandResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* FirmwareDetailsResponse firmwareDetailsResponse = 2; */
        if (message.response.oneofKind === "firmwareDetailsResponse")
            FirmwareDetailsResponse.internalBinaryWrite(message.response.firmwareDetailsResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* UpdateResponse updateResponse = 3; */
        if (message.response.oneofKind === "updateResponse")
            UpdateResponse.internalBinaryWrite(message.response.updateResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ConfigurationResponse configurationResponse = 4; */
        if (message.response.oneofKind === "configurationResponse")
            ConfigurationResponse.internalBinaryWrite(message.response.configurationResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* SetHatImageResponse setHatImageResponse = 5; */
        if (message.response.oneofKind === "setHatImageResponse")
            SetHatImageResponse.internalBinaryWrite(message.response.setHatImageResponse, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* GetDgsrImageValidationResultResponse getDgsrImageValidationResultResponse = 6; */
        if (message.response.oneofKind === "getDgsrImageValidationResultResponse")
            GetDgsrImageValidationResultResponse.internalBinaryWrite(message.response.getDgsrImageValidationResultResponse, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectResponse
 */
export const MyProjectResponse = new MyProjectResponse$Type();
